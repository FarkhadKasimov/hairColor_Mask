<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Hair Color Demo — MediaPipe BodySegmentation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; background:#0e0e10; color:#fff; font-family:system-ui; }
    header { padding:10px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #222; flex-wrap:wrap; }
    main { height:calc(100vh - 56px); position:relative; }
    #wrap { position:relative; width:100%; height:100%; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
    input[type="color"] { width:40px; height:32px; padding:0; border:none; background:transparent; }
    .sep { width:1px; height:24px; background:#333; }
    label { display:flex; align-items:center; gap:6px; }
    small { opacity:0.7 }
  </style>
  <!-- TFJS -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <!-- Body Segmentation -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@0.1.3/dist/body-segmentation.min.js"></script>
</head>
<body>
  <header>
    <button id="startBtn">Запустить камеру</button>

    <label>Режим:
      <select id="mode">
        <option value="mask">Mask (debug)</option>
        <option value="person">Person tint</option>
        <option value="hair">Hair-only (heuristic)</option>
      </select>
    </label>

    <span class="sep"></span>

    <label>Цвет: <input id="colorPicker" type="color" value="#ff3aa5"></label>
    <label>Интенсивность: <input id="strength" type="range" min="0" max="1" step="0.01" value="0.85"></label>

    <label id="darknessWrap">Порог тёмных волос: <input id="darkness" type="range" min="0" max="255" step="1" value="130"></label>

    <small>Подсказка: если блонд — подними «Порог тёмных волос» и/или снизь интенсивность.</small>
  </header>

  <main>
    <div id="wrap">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="out"></canvas>
    </div>
  </main>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('out');
    const ctx = canvas.getContext('2d', { willReadFrequently:true });

    const ui = {
      startBtn: document.getElementById('startBtn'),
      mode: document.getElementById('mode'),
      color: document.getElementById('colorPicker'),
      strength: document.getElementById('strength'),
      darkness: document.getElementById('darkness'),
      darknessWrap: document.getElementById('darknessWrap')
    };

    const state = {
      running: false,
      mode: 'mask',
      color: [255, 58, 165],
      strength: 0.85,
      darkness: 130,
      segmenter: null
    };

    function hexToRgb(hex) {
      const v = hex.replace('#','');
      return [parseInt(v.slice(0,2),16), parseInt(v.slice(2,4),16), parseInt(v.slice(4,6),16)];
    }

    async function setupSegmenter() {
      const model = bodySegmentation.SupportedModels.MediaPipeSelfieSegmentation;
      state.segmenter = await bodySegmentation.createSegmenter(model, {
        runtime: 'mediapipe',
        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation',
        modelType: 'landscape' // попробуй 'general' если будет лучше
      });
    }

    async function start() {
      if (state.running) return;
      state.running = true;

      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream;
      await new Promise(res => video.onloadedmetadata = res);

      // размеры
      canvas.width = video.videoWidth || 1280;
      canvas.height = video.videoHeight || 720;

      await setupSegmenter();
      requestAnimationFrame(loop);
    }

    // == Режим 1: показать бинарную маску (debug) ==
    function drawMask(maskImageData) {
      ctx.putImageData(maskImageData, 0, 0);
    }

    // == Режим 2: перекрасить ВСЕ пиксели человека ==
    function tintPerson(frame, mask, color, strength) {
      const data = frame.data;
      const m = mask.data;
      const [cr, cg, cb] = color;

      for (let i = 0; i < data.length; i += 4) {
        const person = m[i] > 200; // белый=человек
        if (!person) continue;
        const a = strength;
        data[i]   = Math.round(data[i]*(1-a) + cr*a);
        data[i+1] = Math.round(data[i+1]*(1-a) + cg*a);
        data[i+2] = Math.round(data[i+2]*(1-a) + cb*a);
      }
      return frame;
    }

    // == Режим 3: перекрасить только волосы (эвристика) ==
    function tintHair(frame, mask, color, strength, darkness) {
      const data = frame.data;
      const m = mask.data;
      const w = frame.width, h = frame.height;

      // ограничиваемся верхней частью, чтобы не красить бороду/одежду
      const headTop = 0;
      const headBottom = Math.floor(h * 0.62);

      const [cr, cg, cb] = color;

      for (let y = headTop; y < headBottom; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;

          const person = m[i] > 200;
          if (!person) continue;

          const r = data[i], g = data[i+1], b = data[i+2];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b; // яркость
          if (lum < darkness) {
            const a = strength;
            data[i]   = Math.round(r*(1-a) + cr*a);
            data[i+1] = Math.round(g*(1-a) + cg*a);
            data[i+2] = Math.round(b*(1-a) + cb*a);
          }
        }
      }
      return frame;
    }

    async function loop() {
      if (!state.running) return;

      // 1) исходный кадр
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 2) сегментация
      const people = await state.segmenter.segmentPeople(video, { flipHorizontal: true });
      if (!people || !people.length) {
        requestAnimationFrame(loop);
        return;
      }

      // 3) получаем бинарную маску как ImageData
      const mask = await bodySegmentation.toBinaryMask(
        people,
        {r:255, g:255, b:255, a:255}, // человек = белый
        {r:0, g:0, b:0, a:255},       // фон = чёрный
        true,                         // сгладить
        1.0                           // непрозрачность (нам важно значение RGB)
      );

      // 4) визуализация по режиму
      if (state.mode === 'mask') {
        drawMask(mask);
      } else if (state.mode === 'person') {
        const tinted = tintPerson(frame, mask, state.color, state.strength);
        ctx.putImageData(tinted, 0, 0);
      } else { // 'hair'
        const tinted = tintHair(frame, mask, state.color, state.strength, state.darkness);
        ctx.putImageData(tinted, 0, 0);
      }

      requestAnimationFrame(loop);
    }

    // UI bindings
    ui.startBtn.addEventListener('click', start);
    ui.mode.addEventListener('change', (e) => {
      state.mode = e.target.value;
      ui.darknessWrap.style.display = state.mode === 'hair' ? 'flex' : 'none';
    });
    ui.color.addEventListener('input', (e) => state.color = hexToRgb(e.target.value));
    ui.strength.addEventListener('input', (e) => state.strength = parseFloat(e.target.value));
    ui.darkness.addEventListener('input', (e) => state.darkness = parseInt(e.target.value, 10));

    // стартовые настройки
    ui.darknessWrap.style.display = 'none';
  </script>
</body>
</html>
