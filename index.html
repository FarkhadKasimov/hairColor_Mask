<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Hair Color Demo — Body Segmentation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin:0; background:#0e0e10; color:#fff; font-family:system-ui; }
    header { padding:12px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #222; flex-wrap: wrap; }
    main { height:calc(100vh - 60px); position:relative; }
    #wrap { position:relative; width:100%; height:100%; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform:scaleX(-1); }
    input[type="color"] { width:40px; height:32px; padding:0; border:none; background:transparent; }
    small { opacity:0.7 }
  </style>
  <!-- TFJS -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <!-- Body Segmentation -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-segmentation@0.1.3/dist/body-segmentation.min.js"></script>
</head>
<body>
  <header>
    <button id="startBtn">Запустить камеру</button>
    <label>Цвет: <input id="colorPicker" type="color" value="#ff3aa5"></label>
    <label>Интенсивность: <input id="strength" type="range" min="0" max="1" step="0.01" value="0.85"></label>
    <label>Порог тёмных волос: <input id="darkness" type="range" min="0" max="255" step="1" value="130"></label>
    <small>Если блонд — подними «Порог тёмных волос» и/или снизь интенсивность.</small>
  </header>
  <main>
    <div id="wrap">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="out"></canvas>
    </div>
  </main>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('out');
    const ctx = canvas.getContext('2d', { willReadFrequently:true });

    const state = {
      running: false,
      color: [255, 58, 165],
      strength: 0.85,
      darkness: 130,
      segmenter: null
    };

    function hexToRgb(hex) {
      const v = hex.replace('#','');
      return [parseInt(v.slice(0,2),16), parseInt(v.slice(2,4),16), parseInt(v.slice(4,6),16)];
    }

    async function setupSegmenter() {
      const model = bodySegmentation.SupportedModels.MediaPipeSelfieSegmentation;
      state.segmenter = await bodySegmentation.createSegmenter(model, {
        runtime: 'mediapipe',
        // CDN с файлами MediaPipe
        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation',
        modelType: 'landscape' // или 'general' — попробуй оба, landscape часто стабильнее для фронталки
      });
    }

    async function start() {
      if (state.running) return;
      state.running = true;

      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream;
      await new Promise(res => video.onloadedmetadata = res);

      canvas.width = video.videoWidth || 1280;
      canvas.height = video.videoHeight || 720;

      await setupSegmenter();
      requestAnimationFrame(loop);
    }

    // Перекраска: ограничиваемся зоной головы (верхние ~60%),
    // затем берём только тёмные пиксели внутри маски человека (прибл. волосы).
    function tintHair(imageData, maskData, color, strength, darkness) {
      const data = imageData.data;
      const m = maskData.data; // RGBA маска: белое там, где человек
      const w = imageData.width, h = imageData.height;

      const headTop = 0;
      const headBottom = Math.floor(h * 0.62);

      const [cr, cg, cb] = color;

      for (let y = headTop; y < headBottom; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;

          const person = m[i] > 200; // в маске белый=255 => человек
          if (!person) continue;

          const r = data[i], g = data[i+1], b = data[i+2];
          // яркость для отсечения светлых участков (кожа/фон)
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          if (lum < darkness) {
            const a = strength;
            data[i]   = Math.round(r*(1-a) + cr*a);
            data[i+1] = Math.round(g*(1-a) + cg*a);
            data[i+2] = Math.round(b*(1-a) + cb*a);
          }
        }
      }
      return imageData;
    }

    async function loop() {
      if (!state.running) return;

      // 1) Рисуем исходный кадр
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 2) Сегментация (получим маску человека)
      const people = await state.segmenter.segmentPeople(video, { flipHorizontal: true });
      if (!people || !people.length) {
        requestAnimationFrame(loop);
        return;
      }

      // 3) Соберём из mask значение RGBA (255 там где человек)
      // people[0].mask — ImageData-like (или HTMLCanvasElement), используем util:
      const mask = await bodySegmentation.toBinaryMask(
        people,                   // список людей
        {r:255, g:255, b:255, a:255}, // цвет человека
        {r:0, g:0, b:0, a:255},       // фон
        true,                        // smooth — сгладить
        0.7                          // opacity — неважно, мы читаем пиксели
      );

      // 4) Применяем окраску к предполагаемым волосам
      const tinted = tintHair(frame, mask, state.color, state.strength, state.darkness);
      ctx.putImageData(tinted, 0, 0);

      requestAnimationFrame(loop);
    }

    // UI
    document.getElementById('startBtn').addEventListener('click', start);
    document.getElementById('colorPicker').addEventListener('input', (e) => {
      state.color = hexToRgb(e.target.value);
    });
    document.getElementById('strength').addEventListener('input', (e) => {
      state.strength = parseFloat(e.target.value);
    });
    document.getElementById('darkness').addEventListener('input', (e) => {
      state.darkness = parseInt(e.target.value, 10);
    });
  </script>
</body>
</html>
